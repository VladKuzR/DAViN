{"ast":null,"code":"import Airtable from 'airtable';\nconst base = new Airtable({\n  apiKey: process.env.REACT_APP_AIRTABLE_API_KEY\n}).base('appuojNVDfs9U7ccy');\nexport const fetchAirtableData = async () => {\n  try {\n    const records = await base('tbl60mtZmcPavvtQH').select().all();\n    const data = records.map(record => record.fields);\n\n    // Process the data to get ranges and categories\n    const processedData = {\n      phases: [...new Set(data.map(item => Number(item.Phase) || 0))],\n      divisions: [...new Set(data.map(item => item.Division))].filter(Boolean).map(div => String(div).trim()).filter(div => div !== '').sort((a, b) => a.localeCompare(b)).map(div => ({\n        value: div,\n        label: div\n      })),\n      wbsCategories: [...new Set(data.map(item => item['WBS Category Level 1']))].filter(Boolean).sort().map(cat => ({\n        value: cat,\n        label: cat\n      })),\n      durations: data.map(item => Number(item.Duration) || 0),\n      startDates: data.map(item => new Date(item['Start Date'])),\n      endDates: data.map(item => new Date(item['End Date']))\n    };\n\n    // Get min and max dates\n    const validStartDates = processedData.startDates.filter(date => date instanceof Date && !isNaN(date));\n    const validEndDates = processedData.endDates.filter(date => date instanceof Date && !isNaN(date));\n    const maxEndDate = validEndDates.length ? new Date(Math.max(...validEndDates)) : null;\n\n    // Log the divisions for debugging\n    console.log('Processed Divisions:', processedData.divisions);\n    return {\n      raw: data,\n      processed: processedData,\n      ranges: {\n        phase: [Math.min(...processedData.phases), Math.max(...processedData.phases)],\n        duration: [Math.min(...processedData.durations), Math.max(...processedData.durations)],\n        dates: {\n          min: validStartDates.length ? new Date(Math.min(...validStartDates)) : null,\n          max: maxEndDate\n        }\n      }\n    };\n  } catch (error) {\n    console.error('Error fetching Airtable data:', error);\n    return null;\n  }\n};","map":{"version":3,"names":["Airtable","base","apiKey","process","env","REACT_APP_AIRTABLE_API_KEY","fetchAirtableData","records","select","all","data","map","record","fields","processedData","phases","Set","item","Number","Phase","divisions","Division","filter","Boolean","div","String","trim","sort","a","b","localeCompare","value","label","wbsCategories","cat","durations","Duration","startDates","Date","endDates","validStartDates","date","isNaN","validEndDates","maxEndDate","length","Math","max","console","log","raw","processed","ranges","phase","min","duration","dates","error"],"sources":["/home/vl_kuz/DAViN/src/services/airtable.js"],"sourcesContent":["import Airtable from 'airtable';\n\nconst base = new Airtable({\n    apiKey: process.env.REACT_APP_AIRTABLE_API_KEY\n}).base('appuojNVDfs9U7ccy');\n\nexport const fetchAirtableData = async () => {\n    try {\n        const records = await base('tbl60mtZmcPavvtQH').select().all();\n        const data = records.map(record => record.fields);\n\n        // Process the data to get ranges and categories\n        const processedData = {\n            phases: [...new Set(data.map(item => Number(item.Phase) || 0))],\n            divisions: [...new Set(data.map(item => item.Division))]\n                .filter(Boolean)\n                .map(div => String(div).trim())\n                .filter(div => div !== '')\n                .sort((a, b) => a.localeCompare(b))\n                .map(div => ({\n                    value: div,\n                    label: div\n                })),\n            wbsCategories: [...new Set(data.map(item => item['WBS Category Level 1']))]\n                .filter(Boolean)\n                .sort()\n                .map(cat => ({\n                    value: cat,\n                    label: cat\n                })),\n            durations: data.map(item => Number(item.Duration) || 0),\n            startDates: data.map(item => new Date(item['Start Date'])),\n            endDates: data.map(item => new Date(item['End Date']))\n        };\n\n        // Get min and max dates\n        const validStartDates = processedData.startDates.filter(date => date instanceof Date && !isNaN(date));\n        const validEndDates = processedData.endDates.filter(date => date instanceof Date && !isNaN(date));\n\n        const maxEndDate = validEndDates.length ? new Date(Math.max(...validEndDates)) : null;\n\n        // Log the divisions for debugging\n        console.log('Processed Divisions:', processedData.divisions);\n\n        return {\n            raw: data,\n            processed: processedData,\n            ranges: {\n                phase: [Math.min(...processedData.phases), Math.max(...processedData.phases)],\n                duration: [Math.min(...processedData.durations), Math.max(...processedData.durations)],\n                dates: {\n                    min: validStartDates.length ? new Date(Math.min(...validStartDates)) : null,\n                    max: maxEndDate\n                }\n            }\n        };\n    } catch (error) {\n        console.error('Error fetching Airtable data:', error);\n        return null;\n    }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}