{"ast":null,"code":"import Airtable from 'airtable';\nconst base = new Airtable({\n  apiKey: process.env.REACT_APP_AIRTABLE_API_KEY\n}).base('appuojNVDfs9U7ccy');\nexport const fetchAirtableData = async () => {\n  try {\n    // Fetch both tables\n    const recordsMain = await base('tbl60mtZmcPavvtQH').select().all();\n    const recordsDivisions = await base('tblhgavnKoFlFD8SC').select().all();\n\n    // Create a mapping of Division UID to CSI name\n    const divisionMapping = recordsDivisions.reduce((acc, record) => {\n      const fields = record.fields;\n      acc[record.id] = fields['CSI Name'];\n      return acc;\n    }, {});\n    console.log('Division Mapping:', divisionMapping); // Debug log\n\n    const data = recordsMain.map(record => record.fields);\n\n    // Helper function to parse date\n    const parseDate = dateStr => {\n      const date = new Date(dateStr);\n      return date instanceof Date && !isNaN(date) ? date : null;\n    };\n\n    // Process the data to get ranges and categories\n    const processedData = {\n      phases: [...new Set(data.map(item => Number(item.Phase) || 0))],\n      // Map divisions to their CSI names and ensure uniqueness\n      divisions: [...new Set(data.map(item => item.Division))].filter(Boolean).map(div => String(div).trim()).filter(div => div !== '').map(div => ({\n        value: div,\n        label: divisionMapping[div] || `Division ${div}`,\n        sortOrder: Number(div.replace(/\\D/g, '')) || 0\n      }))\n      // Remove duplicates based on CSI names\n      .reduce((unique, item) => {\n        const exists = unique.some(u => u.label === item.label);\n        if (!exists) {\n          unique.push(item);\n        }\n        return unique;\n      }, [])\n      // Sort by division number\n      .sort((a, b) => a.sortOrder - b.sortOrder),\n      wbsCategories: [...new Set(data.map(item => item['WBS Category Level 1']))].filter(Boolean).sort().map(cat => ({\n        value: cat,\n        label: cat\n      })),\n      durations: data.map(item => Number(item.Duration) || 0),\n      startDates: data.map(item => parseDate(item['Start Date'])).filter(Boolean),\n      endDates: data.map(item => parseDate(item['End Date'])).filter(Boolean)\n    };\n\n    // Get min and max dates\n    const minStartDate = processedData.startDates.length ? new Date(Math.min(...processedData.startDates)) : null;\n    const maxEndDate = processedData.endDates.length ? new Date(Math.max(...processedData.endDates)) : null;\n\n    // Debug logs\n    console.log('Raw Division Data:', data.map(item => item.Division));\n    console.log('Division UIDs:', Object.keys(divisionMapping));\n    console.log('CSI Names:', Object.values(divisionMapping));\n    console.log('Final Processed Divisions:', processedData.divisions);\n    return {\n      raw: data,\n      processed: processedData,\n      ranges: {\n        phase: [Math.min(...processedData.phases), Math.max(...processedData.phases)],\n        duration: [Math.min(...processedData.durations), Math.max(...processedData.durations)],\n        dates: {\n          min: minStartDate,\n          max: maxEndDate\n        }\n      }\n    };\n  } catch (error) {\n    console.error('Error fetching Airtable data:', error);\n    return null;\n  }\n};","map":{"version":3,"names":["Airtable","base","apiKey","process","env","REACT_APP_AIRTABLE_API_KEY","fetchAirtableData","recordsMain","select","all","recordsDivisions","divisionMapping","reduce","acc","record","fields","id","console","log","data","map","parseDate","dateStr","date","Date","isNaN","processedData","phases","Set","item","Number","Phase","divisions","Division","filter","Boolean","div","String","trim","value","label","sortOrder","replace","unique","exists","some","u","push","sort","a","b","wbsCategories","cat","durations","Duration","startDates","endDates","minStartDate","length","Math","min","maxEndDate","max","Object","keys","values","raw","processed","ranges","phase","duration","dates","error"],"sources":["/home/vl_kuz/DAViN/src/services/airtable.js"],"sourcesContent":["import Airtable from 'airtable';\n\nconst base = new Airtable({\n    apiKey: process.env.REACT_APP_AIRTABLE_API_KEY\n}).base('appuojNVDfs9U7ccy');\n\nexport const fetchAirtableData = async () => {\n    try {\n        // Fetch both tables\n        const recordsMain = await base('tbl60mtZmcPavvtQH').select().all();\n        const recordsDivisions = await base('tblhgavnKoFlFD8SC').select().all();\n\n        // Create a mapping of Division UID to CSI name\n        const divisionMapping = recordsDivisions.reduce((acc, record) => {\n            const fields = record.fields;\n            acc[record.id] = fields['CSI Name'];\n            return acc;\n        }, {});\n\n        console.log('Division Mapping:', divisionMapping); // Debug log\n\n        const data = recordsMain.map(record => record.fields);\n\n        // Helper function to parse date\n        const parseDate = (dateStr) => {\n            const date = new Date(dateStr);\n            return date instanceof Date && !isNaN(date) ? date : null;\n        };\n\n        // Process the data to get ranges and categories\n        const processedData = {\n            phases: [...new Set(data.map(item => Number(item.Phase) || 0))],\n            // Map divisions to their CSI names and ensure uniqueness\n            divisions: [...new Set(data.map(item => item.Division))]\n                .filter(Boolean)\n                .map(div => String(div).trim())\n                .filter(div => div !== '')\n                .map(div => ({\n                    value: div,\n                    label: divisionMapping[div] || `Division ${div}`,\n                    sortOrder: Number(div.replace(/\\D/g, '')) || 0\n                }))\n                // Remove duplicates based on CSI names\n                .reduce((unique, item) => {\n                    const exists = unique.some(u => u.label === item.label);\n                    if (!exists) {\n                        unique.push(item);\n                    }\n                    return unique;\n                }, [])\n                // Sort by division number\n                .sort((a, b) => a.sortOrder - b.sortOrder),\n            wbsCategories: [...new Set(data.map(item => item['WBS Category Level 1']))]\n                .filter(Boolean)\n                .sort()\n                .map(cat => ({\n                    value: cat,\n                    label: cat\n                })),\n            durations: data.map(item => Number(item.Duration) || 0),\n            startDates: data.map(item => parseDate(item['Start Date'])).filter(Boolean),\n            endDates: data.map(item => parseDate(item['End Date'])).filter(Boolean)\n        };\n\n        // Get min and max dates\n        const minStartDate = processedData.startDates.length\n            ? new Date(Math.min(...processedData.startDates))\n            : null;\n\n        const maxEndDate = processedData.endDates.length\n            ? new Date(Math.max(...processedData.endDates))\n            : null;\n\n        // Debug logs\n        console.log('Raw Division Data:', data.map(item => item.Division));\n        console.log('Division UIDs:', Object.keys(divisionMapping));\n        console.log('CSI Names:', Object.values(divisionMapping));\n        console.log('Final Processed Divisions:', processedData.divisions);\n\n        return {\n            raw: data,\n            processed: processedData,\n            ranges: {\n                phase: [Math.min(...processedData.phases), Math.max(...processedData.phases)],\n                duration: [Math.min(...processedData.durations), Math.max(...processedData.durations)],\n                dates: {\n                    min: minStartDate,\n                    max: maxEndDate\n                }\n            }\n        };\n    } catch (error) {\n        console.error('Error fetching Airtable data:', error);\n        return null;\n    }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}